#!/usr/bin/env bash

# Changelog Generator Script (Versioned, Grouped by Tag)
# Usage: ./generate_changelog.sh [output_file]

set -euo pipefail

DEFAULT_OUTPUT="CHANGELOG.md"
REPO_ROOT=$(git rev-parse --show-toplevel)
OUTPUT_FILE=${1:-$DEFAULT_OUTPUT}

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

print_status() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_error "Not in a git repository!"
    exit 1
fi

# Extract the <version> that is a direct child of <project> (not from <parent> or elsewhere)
POM_VERSION=$(awk '/<project/{p=1} p && /<groupId>com.example<\/groupId>/{g=1} g && /<version>/{print; exit}' "$REPO_ROOT/pom.xml" | sed -E 's/.*<version>([^<]+)<\/version>.*/\1/')

# Get all tags sorted by version (annotated and lightweight)
TAGS=( $(git tag --sort=-creatordate) )

# If no tags, use all history as one version
if [ ${#TAGS[@]} -eq 0 ]; then
    TAGS=("HEAD")
fi

# If the changelog file exists, preserve its previous content (except the autogenerated header)
if [ -f "$OUTPUT_FILE" ]; then
    awk '/^## \[/{flag=1} flag' "$OUTPUT_FILE" > "$OUTPUT_FILE.prev" || true
else
    > "$OUTPUT_FILE.prev"
fi

# Write new header and version
{
    echo "# Changelog"
    echo ""
    echo "**Current Version (pom.xml)**: $POM_VERSION"
    echo ""
} > "$OUTPUT_FILE"

PREV=""
for TAG in "${TAGS[@]}"; do
    if [ "$TAG" = "HEAD" ]; then
        RANGE=""
        VERSION="Unreleased"
        DATE=$(date '+%Y-%m-%d')
    else
        VERSION="$TAG"
        DATE=$(git log -1 --format="%ad" --date=short "$TAG")
        RANGE="$TAG"
    fi

    # Get commit range for this tag
    if [ -z "$PREV" ]; then
        COMMITS=$(git log "$RANGE" --pretty=format:"%H|%s|%an|%ad" --date=short)
    else
        COMMITS=$(git log "$TAG".."$PREV" --pretty=format:"%H|%s|%an|%ad" --date=short)
    fi
    PREV="$TAG"

    # Categorize commits (use plain arrays for POSIX compatibility)
    ADDED=""; FIXED=""; DOCS=""; OTHER=""
    while IFS='|' read -r hash subject author date; do
        case "$subject" in
            feat:*) ADDED+="- $(echo "$subject" | sed -E 's/^feat:\s*//') ($author)\n" ;;
            fix:*) FIXED+="- $(echo "$subject" | sed -E 's/^fix:\s*//') ($author)\n" ;;
            docs:*) DOCS+="- $(echo "$subject" | sed -E 's/^docs:\s*//') ($author)\n" ;;
            *) OTHER+="- $subject ($author)\n" ;;
        esac
    done <<< "$COMMITS"

    # Print version header
    echo "## [$VERSION] - $DATE" >> "$OUTPUT_FILE"

    if [ -n "$ADDED" ]; then
        echo "### Added" >> "$OUTPUT_FILE"
        echo -e "$ADDED" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
    fi
    if [ -n "$FIXED" ]; then
        echo "### Fixed" >> "$OUTPUT_FILE"
        echo -e "$FIXED" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
    fi
    if [ -n "$DOCS" ]; then
        echo "### Documentation" >> "$OUTPUT_FILE"
        echo -e "$DOCS" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
    fi
    if [ -n "$OTHER" ]; then
        echo "### Other" >> "$OUTPUT_FILE"
        echo -e "$OTHER" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
    fi
done

# Append previous changelog (if any)
if [ -s "$OUTPUT_FILE.prev" ]; then
    cat "$OUTPUT_FILE.prev" >> "$OUTPUT_FILE"
    rm "$OUTPUT_FILE.prev"
fi

print_status "Changelog generated in $OUTPUT_FILE in requested format."
